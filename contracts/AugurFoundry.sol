pragma solidity ^0.6.2;
import "./ERC20Wrapper.sol";
import "./IWETH.sol";
import "./IShareToken.sol";

pragma experimental ABIEncoderV2;

/**
 * @dev This is a factory that creates Wrappers around ERC1155 shareTokens generated by AugurETH
 * as shares on outcomes of markets.
 * This is a version that supports AugurETH (para augur deployed for WETH)
 * For every outcome there will be one wrapper.
 * @author yashnaman
 */
contract AugurFoundry {
    IShareToken public shareToken;
    IWETH public wETH;
    address public augur;

    mapping(uint256 => address payable) public wrappers;

    event WrapperCreated(uint256 indexed tokenId, address tokenAddress);

    /**@dev sets value for {shareToken} and {wETH}
     * @param _shareToken address of shareToken associated with a augur universe
     *@param _wETH DAI
     */
    constructor(
        IShareToken _shareToken,
        IWETH _wETH,
        address _augur
    ) public {
        wETH = _wETH;
        shareToken = _shareToken;
        augur = _augur;
        _wETH.approve(_augur, uint256(-1));
    }

    function approveWrappedETHtoAugur() external {
        wETH.approve(address(augur), uint256(-1));
    }

    /**@dev creates new ERC20 wrappers for a outcome of a market
     *@param _tokenId token id associated with a outcome of a market
     *@param _name a descriptive name mentioning market and outcome
     *@param _symbol symbol for the ERC20 wrapper
     *@param decimals decimals for the ERC20 wrapper
     */
    function newERC20Wrapper(
        uint256 _tokenId,
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) public {
        require(wrappers[_tokenId] == address(0), "Wrapper already created");
        ERC20Wrapper erc20Wrapper = new ERC20Wrapper(
            address(this),
            shareToken,
            wETH,
            _tokenId,
            _name,
            _symbol,
            _decimals
        );
        wrappers[_tokenId] = address(erc20Wrapper);
        emit WrapperCreated(_tokenId, address(erc20Wrapper));
    }

    /**@dev creates new ERC20 wrappers for multiple tokenIds*/
    function newERC20Wrappers(
        uint256[] memory _tokenIds,
        string[] memory _names,
        string[] memory _symbols,
        uint8[] memory _decimals
    ) public {
        require(
            _tokenIds.length == _names.length &&
                _tokenIds.length == _symbols.length
        );
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            newERC20Wrapper(_tokenIds[i], _names[i], _symbols[i], _decimals[i]);
        }
    }

    /**@dev A function that wraps ERC1155s shareToken into ERC20s
     * Requirements:
     *
     * -  msg.sender has setApprovalForAll to this contract
     * @param _tokenId token id associated with a outcome of a market
     * @param _account account the newly minted ERC20s will go to
     * @param _amount  amount of tokens to be wrapped
     */
    function wrapTokens(
        uint256 _tokenId,
        address _account,
        uint256 _amount
    ) public {
        ERC20Wrapper erc20Wrapper = ERC20Wrapper(wrappers[_tokenId]);
        shareToken.safeTransferFrom(
            msg.sender,
            address(erc20Wrapper),
            _tokenId,
            _amount,
            ""
        );
        erc20Wrapper.wrapTokens(_account, _amount);
    }

    /**@dev A function that burns ERC20s and gives back ERC1155s
     * Requirements:
     *
     * - msg.sender has more than _amount of ERC20 tokens associated with _tokenId.
     * - if the market has finalized then it is  advised that you call claim() on ERC20Wrapper
     * contract associated with the winning outcome
     * @param _tokenId token id associated with a outcome of a market
     * @param _amount amount of tokens to be unwrapped
     */
    function unWrapTokens(uint256 _tokenId, uint256 _amount) public {
        ERC20Wrapper erc20Wrapper = ERC20Wrapper(wrappers[_tokenId]);
        erc20Wrapper.unWrapTokens(msg.sender, _amount);
    }

    /**@dev wraps multiple tokens */
    function wrapMultipleTokens(
        uint256[] memory _tokenIds,
        address _account,
        uint256[] memory _amounts
    ) public {
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            wrapTokens(_tokenIds[i], _account, _amounts[i]);
        }
    }

    /**@dev unwraps multiple tokens */
    function unWrapMultipleTokens(
        uint256[] memory _tokenIds,
        uint256[] memory _amounts
    ) public {
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            unWrapTokens(_tokenIds[i], _amounts[i]);
        }
    }

    /**
     * @notice A  Helper function to Buy some amount of complete sets for a market with ETH (on Augur ETH)
     ** Requirements:
     *
     * - msg.value should be equal to _amount * numTicks of the _market
     * @param _market The market to purchase complete sets in
     * @param _account The account receiving the complete sets
     * @param _amount The number of complete sets to purchase
     * @return Bool True
     */
    function buyCompleteSets(
        address _market,
        address _account,
        uint256 _amount
    ) external payable returns (bool) {
        wETH.deposit{value: msg.value}();
        return shareToken.buyCompleteSets(_market, _account, _amount);
    }

    /**
     * @notice A Helper function to Sell some amount of complete sets for a market and get back ETH (on AugurETH)
     ** Requirements:
     *
     * -  msg.sender has setApprovalForAll their sharetokens to this contract
     * @param _market The market to sell complete sets in
     * @param _holder The holder of the complete sets
     * @param _recipient The recipient of funds from the sale
     * @param _amount The number of complete sets to sell
     * @param _fingerprint Fingerprint of the filler used to naively restrict affiliate fee dispursement
     * @return (uint256 _creatorFee, uint256 _reportingFee) The fees taken for the market creator and reporting respectively
     */
    function sellCompleteSets(
        address _market,
        address _recipient,
        uint256 _amount,
        bytes32 _fingerprint
    ) external returns (uint256 _creatorFee, uint256 _reportingFee) {
        shareToken.sellCompleteSets(
            _market,
            msg.sender,
            address(this),
            _amount,
            _fingerprint
        );
        uint256 wETHBalance = wETH.balanceOf(address(this));
        wETH.withdraw(wETHBalance);
        TransferHelper.safeTransferETH(_recipient, wETHBalance);
    }

    receive() external payable {
        assert(msg.sender == address(wETH)); // only accept ETH via fallback from the WETH contract
    }
}
